wrapper {
  gradleVersion = "2.4"
}

enum Platform {
  OsX,
  Windows,
  Linux
}

def platforms = ['mac os x': Platform.OsX, 'windows': Platform.Windows, 'linux': Platform.Linux]

def platform = {
  return platforms[System.properties['os.name'].toLowerCase()]
}

apply plugin: 'cpp'
apply plugin: 'c'

task lex(type: LexCompiler) {
  sourceDir = project.file("${buildDir}/src/generated/lex")
  headerDir = project.file("${buildDir}/src/generated/lex")
  lexFiles = files('src/chuck.lex')
}

task yacc(type: YaccCompiler) {
  sourceDir = project.file("${buildDir}/src/generated/yacc")
  headerDir = project.file("${buildDir}/src/generated/yacc")
  yaccFiles = files('src/chuck.y')
}

binaries.all {
  // Define toolchain-specific compiler and linker options
  if (platform() == Platform.OsX) {
    // TODO: Determine automatically
    cCompiler.args '-DHAVE_CONFIG_H', '-D__MACOSX_CORE__', '-isysroot',
      '/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk', \
      '-mmacosx-version-min=10.4'
    cppCompiler.args '-D__MACOSX_CORE__', '-isysroot', \
      '/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk', \
      '-mmacosx-version-min=10.4'
    linker.args '-F/System/Library/PrivateFrameworks', '-weak_framework', 'MultitouchSupport', \
      '-framework', 'CoreAudio', '-framework', 'CoreMIDI', '-framework', 'CoreFoundation', '-framework', \
      'IOKit', '-framework', 'Carbon', '-framework', 'AppKit', '-framework', 'Foundation', \
      '-mmacosx-version-min=10.4'
  }
}

class LexCompiler extends DefaultTask {
    @InputFiles FileCollection lexFiles
    @OutputDirectory File sourceDir
    @OutputDirectory File headerDir

    @TaskAction
    void processLexFiles() {
      lexFiles.each { file ->
        project.exec {
          commandLine = ['flex', '-o', new File(sourceDir, file.name - '.lex' + '.yy.c').absolutePath,
            file.absolutePath]
        }
      }
    }
}

class YaccCompiler extends DefaultTask {
    @InputFiles FileCollection yaccFiles
    @OutputDirectory File sourceDir
    @OutputDirectory File headerDir

    @TaskAction
    void processYaccFiles() {
      yaccFiles.each { file ->
        project.exec {
          commandLine = ['bison', '-dv', '-o', new File(sourceDir, file.name - '.y' + '.tab.c'),
            file.absolutePath]
        }
      }
    }
}

model {
  components {
    chuck(NativeExecutableSpec) {
      sources.all {
        exportedHeaders {
          srcDir 'src'
          srcDir 'src/lo'
        }
      }
      sources {
        yaccOutput(CSourceSet) {
          generatedBy tasks.yacc
          source.include '*.c'
        }
        lexOutput(CSourceSet) {
          generatedBy tasks.lex
          source.include '*.c'
          lib sources.yaccOutput
        }
        c {
          source {
            srcDir 'src'
            include '*.c'
            include 'lo/*.c'
            if (platform() != Platform.Windows) {
              exclude 'chuck_win32.c'
            }
            if (platform() != Platform.OsX) {
              exclude 'util_sndfile.c'
            }
          }
          lib sources.lexOutput
          lib sources.yaccOutput
        }
        cpp {
          source {
            srcDir 'src'
            include '*.cpp'
            include 'RtAudio/*.cpp'
            exclude 'rtaudio_c.cpp'
            exclude 'chuck_js.cpp'
            exclude 'digiio_webaudio.cpp'
          }
        }
      }
    }
  }
}

class EmscriptenBaseTask extends DefaultTask {
  // TODO: Make not fail in case $EMSCRIPTEN is undefined
  def emccPath = new File(System.getenv("EMSCRIPTEN"), 'emcc').absolutePath
}

class EmscriptenCompiler extends EmscriptenBaseTask {
  @InputFiles FileCollection emscriptenFiles
  @OutputDirectory File outputDirectory

  def replaceExtension(fileName) {
    if (fileName.endsWith('.cpp')) {
      return fileName - '.cpp' + '.o'
    }
    if (fileName.endsWith('.c')) {
      return fileName - '.c' + '.o'
    }
  }

  @TaskAction
  void processEmscriptenFiles(IncrementalTaskInputs inputs) {
    inputs.outOfDate { change ->
      project.exec {
        // TODO: Make -g configurable, don't hardcode YACC header dir
        commandLine = [emccPath, '-Isrc', '-Isrc/lo', '-Ibuild/src/generated/yacc', '-g', '-o',
          new File(outputDirectory, replaceExtension(change.file.name)).absolutePath,
          change.file.absolutePath]
      }
    }

    inputs.removed { change ->
      new File(outputDirectory, replaceExtension(change.file.name)).delete()
    }
  }
}

class EmscriptenLinker extends EmscriptenBaseTask {
  @InputFiles FileCollection emscriptenFiles
  @OutputDirectory File outputDirectory

  @TaskAction
  void processEmscriptenFiles() {
    project.exec {
      // TODO: Make -g and SAFE_HEAP configurable
      commandLine = [emccPath, '-g', '-s', 'EXPORTED_FUNCTIONS=["_executeCode"]', '--js-library',
        'src/emscripten/libraries/webaudio.js', '-s', 'SAFE_HEAP=1', '-s DEMANGLE_SUPPORT=1', '-o',
        new File(outputDirectory, 'chuck.js').absolutePath] + emscriptenFiles.collect { it.absolutePath }
    }
  }
}

task emscriptenYacc(type: EmscriptenCompiler) {
  outputDirectory = file("${buildDir}/emscripten")
  emscriptenFiles = fileTree(tasks.yacc.sourceDir)
    .include('chuck.tab.c')
  dependsOn(tasks.yacc)
}

task emscriptenLex(type: EmscriptenCompiler) {
  outputDirectory = file("${buildDir}/emscripten")
  emscriptenFiles = fileTree(tasks.lex.sourceDir)
    .include('chuck.yy.c')
  dependsOn(tasks.lex)
  dependsOn(tasks.yacc)
}

task emscriptenCompile(type: EmscriptenCompiler) {
  outputDirectory = file("${buildDir}/emscripten")
  emscriptenFiles = fileTree(dir: 'src')
    .include('*.c')
    .include('*.cpp')
    .exclude('rtaudio_c.cpp')
    .exclude('digiio_rtaudio.cpp')
    .exclude('util_sndfile.c')
    .exclude('chuck_win32.c')

  dependsOn(tasks.yacc)
}

task emscripten(type: EmscriptenLinker) {
  outputDirectory = file("${buildDir}/js")
  emscriptenFiles = tasks.emscriptenYacc.outputs.files.asFileTree + \
    tasks.emscriptenLex.outputs.files.asFileTree + tasks.emscriptenCompile.outputs.files.asFileTree
}
